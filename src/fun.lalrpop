use crate::lexer::{self, Token};
use crate::ast::{Term};

grammar<'input>;

extern {
	type Location = usize;
	type Error = lexer::Error;

	enum Token<'input> {
		"\\" => Token::BackSlash,
		"->" => Token::Arrow,
		"(" => Token::LParen,
		")" => Token::RParen,
		"=" => Token::Equals,
		":" => Token::Colon,
		"let" => Token::Let,
		"in" => Token::In,
		"case" => Token::Case,
		"of" => Token::Of,
		"{" => Token::LayoutStart,
		"," => Token::LayoutSep,
		"}" => Token::LayoutEnd,
		Num => Token::Number(<i32>),
		Ident => Token::Ident(<&'input str>),
	}
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Binding: (&'input str, Option<Box<Term<'input>>>, Box<Term<'input>>) = {
	<x:Ident> "=" <e:Term> => (x, None, e),
	<x:Ident> ":" <t:Term> "=" <e:Term> => (x, Some(t), e),
}

pub Term: Box<Term<'input>> = {
	Term1,
	"\\" <x:Ident> "->" <e:Term1> => Box::new(Term::Abs(x, e)),

	"case" <_x:Term> "of" "{" Comma<Arm> "}" => Box::new(Term::Number(69)),

	"let" "{" <bs:Comma<Binding>> "}" "in" <e:Term> => {
		bs.into_iter().rev().fold(e, |acc, (x, _t, v)| Box::new(Term::App(Box::new(Term::Abs(x, acc)), v)))
	},
};

Term1: Box<Term<'input>> = {
	Term2,
	Term1 Term2 => Box::new(Term::App(<>)),
}

Term2: Box<Term<'input>> = {
	Num => Box::new(Term::Number(<>)),
	Ident => Box::new(Term::Var(<>)),
	"(" <Term> ")",
};

Arm: () = {
	Term "->" Term => {},
};