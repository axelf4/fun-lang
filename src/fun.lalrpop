use crate::lexer::{self, Token};
use crate::ast::{Expr};

grammar<'input>;

extern {
	type Location = usize;
	type Error = lexer::Error;

	enum Token<'input> {
		"\\" => Token::BackSlash,
		"->" => Token::Arrow,
		"(" => Token::LParen,
		")" => Token::RParen,
		"=" => Token::Equals,
		":" => Token::Colon,
		"let" => Token::Let,
		"in" => Token::In,
		"case" => Token::Case,
		"of" => Token::Of,
		"{" => Token::LayoutStart,
		"," => Token::LayoutSep,
		"}" => Token::LayoutEnd,
		Num => Token::Number(<i32>),
		Ident => Token::Ident(<&'input str>),
	}
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Binding: (&'input str, Option<Box<Expr<'input>>>, Box<Expr<'input>>) = {
	<x:Ident> "=" <e:Expr> => (x, None, e),
	<x:Ident> ":" <t:Expr> "=" <e:Expr> => (x, Some(t), e),
}

pub Expr: Box<Expr<'input>> = {
	Expr1,
	"\\" <x:Ident> "->" <e:Expr1> => Box::new(Expr::Abs(x, e)),

	"case" <_x:Expr> "of" "{" Comma<Arm> "}" => Box::new(Expr::Number(69)),

	"let" "{" <bs:Comma<Binding>> "}" "in" <e:Expr> => {
		bs.into_iter().rev().fold(e, |acc, (x, _t, v)| Box::new(Expr::App(Box::new(Expr::Abs(x, acc)), v)))
	},
};

Expr1: Box<Expr<'input>> = {
	Expr2,
	Expr1 Expr2 => Box::new(Expr::App(<>)),
}

Expr2: Box<Expr<'input>> = {
	Num => Box::new(Expr::Number(<>)),
	Ident => Box::new(Expr::Var(<>)),
	"(" <Expr> ")",
};

Arm: () = {
	Expr "->" Expr => {},
};